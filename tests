local owners = {"timnatood7012","viviwave_2"}
local admins = {"timnatood7012","viviwave_2"}
local tempAdmins = {}
local mods = {}
local prefix = "!"
local vipAdminBadgeId = 0
local groupId = 1897513544
local groupRank = 255

local bannedPlayers = {1195840300,jgvvbk2667}
local mutedPlayers = {}
local commandLogs = {}
local playerData = {}
local warnings = {}
local afkPlayers = {}

local maxCommandLength = 20000
local rateLimit = {}
local pendingCommands = {}

local function isOwner(playerName)
	if not playerName or type(playerName) ~= "string" then return false end
	local lowerName = playerName:lower()
	for _, name in ipairs(owners) do
		if tostring(name):lower() == lowerName then return true end
	end
	return false
end

local function isAdmin(playerName)
	if not playerName or type(playerName) ~= "string" then return false end
	if isOwner(playerName) then return true end

	local lowerName = playerName:lower()
	for _, name in ipairs(admins) do
		if tostring(name):lower() == lowerName then return true end
	end
	for _, name in ipairs(tempAdmins) do
		if tostring(name):lower() == lowerName then return true end
	end
	return false
end

local function isMod(playerName)
	if not playerName or type(playerName) ~= "string" then return false end
	if isAdmin(playerName) then return true end

	local lowerName = playerName:lower()
	for _, name in ipairs(mods) do
		if tostring(name):lower() == lowerName then return true end
	end
	return false
end

local function isBanned(playerName)
	if not playerName or type(playerName) ~= "string" then return false end
	local lowerName = playerName:lower()
	for _, name in ipairs(bannedPlayers) do
		if tostring(name):lower() == lowerName then return true end
	end
	return false
end

local function isMuted(playerName)
	if not playerName or type(playerName) ~= "string" then return false end
	local lowerName = playerName:lower()
	for _, name in ipairs(mutedPlayers) do
		if tostring(name):lower() == lowerName then return true end
	end
	return false
end

local groupCache = {}
local function isGroupAdmin(player)
	if not player or not player:IsA("Player") then return false end
	if groupId == 0 then return false end

	local userId = player.UserId
	if groupCache[userId] ~= nil then
		return groupCache[userId]
	end

	local success, result = pcall(function()
		return player:GetRankInGroup(groupId) >= groupRank
	end)

	groupCache[userId] = success and result
	return groupCache[userId] or false
end

local function checkRateLimit(player)
	if not player or not player:IsA("Player") then return false end

	local now = tick()
	local playerName = player.Name

	for name, data in pairs(rateLimit) do
		if now - data.time > 30 then
			rateLimit[name] = nil
		end
	end

	if not rateLimit[playerName] then
		rateLimit[playerName] = {count = 1, time = now}
		return true
	end

	if now - rateLimit[playerName].time > 10 then
		rateLimit[playerName] = {count = 1, time = now}
		return true
	end

	rateLimit[playerName].count = rateLimit[playerName].count + 1
	if rateLimit[playerName].count > 5 then
	
		return false
	end

	return true
end

local function getPlayers(plr, str)
	if not str or type(str) ~= "string" then return {} end

	str = str:lower():gsub("%s+", "")
	local targets = {}
	local allPlayers = game.Players:GetPlayers()

	if str == "all" then
		targets = allPlayers
	elseif str == "others" then
		for _, p in ipairs(allPlayers) do
			if p ~= plr and p:IsA("Player") then
				table.insert(targets, p)
			end
		end
	elseif str == "me" then
		if plr and plr:IsA("Player") then
			table.insert(targets, plr)
		end
	elseif str == "admins" then
		for _, p in ipairs(allPlayers) do
			if p:IsA("Player") and isAdmin(p.Name) then
				table.insert(targets, p)
			end
		end
	elseif str == "nonadmins" then
		for _, p in ipairs(allPlayers) do
			if p:IsA("Player") and not isAdmin(p.Name) then
				table.insert(targets, p)
			end
		end
	elseif str == "mods" then
		for _, p in ipairs(allPlayers) do
			if p:IsA("Player") and isMod(p.Name) then
				table.insert(targets, p)
			end
		end
	elseif str == "random" then
		if #allPlayers > 0 then
			table.insert(targets, allPlayers[math.random(1, #allPlayers)])
		end
	elseif str == "banned" then
		for _, name in ipairs(bannedPlayers) do
			local player = game.Players:FindFirstChild(name)
			if player and player:IsA("Player") then
				table.insert(targets, player)
			end
		end
	elseif str == "muted" then
		for _, name in ipairs(mutedPlayers) do
			local player = game.Players:FindFirstChild(name)
			if player and player:IsA("Player") then
				table.insert(targets, player)
			end
		end
	else
		for _, p in ipairs(allPlayers) do
			if p:IsA("Player") and p.Name:lower():find(str, 1, true) then
				table.insert(targets, p)
			end
		end
	end

	return targets
end

local function createMessageGui(parent, title, messageText, duration, messageType)
	if not parent or not parent:IsA("PlayerGui") then return nil end

	duration = duration or 5

	for _, gui in ipairs(parent:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "AdminMessageGUI" then
			gui:Destroy()
		end
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = "AdminMessageGUI"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true

	local mainContainer = Instance.new("Frame")
	mainContainer.Size = UDim2.new(0, 450, 0, 300)
	mainContainer.Position = UDim2.new(0.5, -225, 0.5, -150)
	mainContainer.BackgroundTransparency = 1
	mainContainer.Parent = gui

	local shadow = Instance.new("Frame")
	shadow.Size = UDim2.new(1, 8, 1, 8)
	shadow.Position = UDim2.new(0, 4, 0, 4)
	shadow.BackgroundColor3 = Color3.new(0, 0, 0)
	shadow.BackgroundTransparency = 0.7
	shadow.BorderSizePixel = 0
	shadow.Parent = mainContainer

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(1, 0, 1, 0)
	mainFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.15)
	mainFrame.BorderSizePixel = 2
	mainFrame.BorderColor3 = Color3.new(0.3, 0.3, 0.4)
	mainFrame.Parent = mainContainer

	local titleBar = Instance.new("Frame")
	titleBar.Size = UDim2.new(1, 0, 0, 40)
	titleBar.BorderSizePixel = 0
	titleBar.Parent = mainFrame

	if messageType == "error" then
		titleBar.BackgroundColor3 = Color3.new(0.6, 0.1, 0.1)
	elseif messageType == "warning" then
		titleBar.BackgroundColor3 = Color3.new(0.7, 0.5, 0)
	elseif messageType == "success" then
		titleBar.BackgroundColor3 = Color3.new(0.1, 0.6, 0.1)
	else
		titleBar.BackgroundColor3 = Color3.new(0.1, 0.3, 0.6)
	end

	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 30, 0, 30)
	icon.Position = UDim2.new(0, 10, 0.5, -15)
	icon.Font = Enum.Font.ArialBold
	icon.TextSize = 20
	icon.BackgroundTransparency = 1
	icon.TextColor3 = Color3.new(1, 1, 1)

	if messageType == "error" then
		icon.Text = "X"
	elseif messageType == "warning" then
		icon.Text = "âš "
	elseif messageType == "success" then
		icon.Text = "Y"
	else
		icon.Text = "â„¹"
	end

	icon.Parent = titleBar

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -50, 1, 0)
	titleLabel.Position = UDim2.new(0, 50, 0, 0)
	titleLabel.Text = title or "Message"
	titleLabel.TextColor3 = Color3.new(1, 1, 1)
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.TextSize = 18
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.BackgroundTransparency = 1
	titleLabel.Parent = titleBar

	local contentFrame = Instance.new("Frame")
	contentFrame.Size = UDim2.new(1, -20, 1, -60)
	contentFrame.Position = UDim2.new(0, 10, 0, 50)
	contentFrame.BackgroundTransparency = 1
	contentFrame.Parent = mainFrame

	local scrollFrame = Instance.new("ScrollingFrame")
	scrollFrame.Size = UDim2.new(1, 0, 1, 0)
	scrollFrame.BackgroundTransparency = 1
	scrollFrame.BorderSizePixel = 0
	scrollFrame.ScrollBarThickness = 6
	scrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
	scrollFrame.Parent = contentFrame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, -4, 0, 0)
	messageLabel.Text = messageText or ""
	messageLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9)
	messageLabel.Font = Enum.Font.Arial
	messageLabel.TextSize = 14
	messageLabel.TextWrapped = true
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.BackgroundTransparency = 1
	messageLabel.Parent = scrollFrame

	local textService = game:GetService("TextService")
	local textSize = textService:GetTextSize(
		messageText or "",
		14,
		Enum.Font.Arial,
		Vector2.new(400, math.huge)
	)

	messageLabel.Size = UDim2.new(1, -4, 0, math.max(50, textSize.Y + 10))
	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, textSize.Y + 20)

	local timerBar = Instance.new("Frame")
	timerBar.Size = UDim2.new(1, 0, 0, 3)
	timerBar.Position = UDim2.new(0, 0, 1, -3)
	timerBar.BackgroundColor3 = titleBar.BackgroundColor3
	timerBar.BorderSizePixel = 0
	timerBar.Parent = mainFrame

	gui.Parent = parent

	spawn(function()
		local startTime = tick()
		local endTime = startTime + duration

		while tick() < endTime and gui.Parent do
			local elapsed = tick() - startTime
			local progress = elapsed / duration
			timerBar.Size = UDim2.new(1 - progress, 0, 0, 3)
			wait(0.1)
		end

		if gui.Parent then
			gui:Destroy()
		end
	end)

	return gui
end

local function createHintGui(parent, messageText, duration)
	if not parent or not parent:IsA("PlayerGui") then return nil end

	duration = duration or 3

	for _, gui in ipairs(parent:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "AdminHintGUI" then
			gui:Destroy()
		end
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = "Admin"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0.6, 0, 0, 50)
	mainFrame.Position = UDim2.new(0.2, 0, 0.02, 0)
	mainFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.15)
	mainFrame.BackgroundTransparency = 0.2
	mainFrame.BorderSizePixel = 2
	mainFrame.BorderColor3 = Color3.new(0.3, 0.3, 0.4)
	mainFrame.Parent = gui

	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 30, 0, 30)
	icon.Position = UDim2.new(0, 10, 0.5, -15)
	icon.Text = "ðŸ’¬"
	icon.Font = Enum.Font.ArialBold
	icon.TextSize = 20
	icon.BackgroundTransparency = 1
	icon.TextColor3 = Color3.new(1, 1, 1)
	icon.Parent = mainFrame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, -50, 1, 0)
	messageLabel.Position = UDim2.new(0, 50, 0, 0)
	messageLabel.Text = messageText or ""
	messageLabel.TextColor3 = Color3.new(1, 1, 1)
	messageLabel.Font = Enum.Font.ArialBold
	messageLabel.TextSize = 14
	messageLabel.BackgroundTransparency = 1
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.Parent = mainFrame

	local timerBar = Instance.new("Frame")
	timerBar.Size = UDim2.new(1, 0, 0, 3)
	timerBar.Position = UDim2.new(0, 0, 1, -3)
	timerBar.BackgroundColor3 = Color3.new(0.2, 0.6, 1)
	timerBar.BorderSizePixel = 0
	timerBar.Parent = mainFrame

	gui.Parent = parent

	mainFrame.Position = UDim2.new(0.2, 0, -0.1, 0)

	spawn(function()
		
		for i = 1, 10 do
			mainFrame.Position = UDim2.new(0.2, 0, -0.1 + (i * 0.01), 0)
			wait(0.01)
		end

		local startTime = tick()
		local endTime = startTime + duration

		while tick() < endTime and gui.Parent do
			local elapsed = tick() - startTime
			local progress = elapsed / duration
			timerBar.Size = UDim2.new(1 - progress, 0, 0, 3)
			wait(0.05)
		end

		for i = 1, 10 do
			mainFrame.Position = UDim2.new(0.2, 0, 0.02 - (i * 0.01), 0)
			wait(0.01)
		end

		if gui.Parent then
			gui:Destroy()
		end
	end)

	return gui
end

local function createToastGui(parent, messageText, duration, toastType)
	if not parent or not parent:IsA("PlayerGui") then return nil end

	duration = duration or 3
	toastType = toastType or "info"

	for _, gui in ipairs(parent:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "AdminToastGUI" then
			gui:Destroy()
		end
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = "AdminToastGUI"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0, 350, 0, 70)
	mainFrame.Position = UDim2.new(0.5, -175, 0.85, 0)
	mainFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.15)
	mainFrame.BackgroundTransparency = 0.1
	mainFrame.BorderSizePixel = 2
	mainFrame.BorderColor3 = Color3.new(0.3, 0.3, 0.4)
	mainFrame.Parent = gui

	-- Determine colors and icon
	local backgroundColor, iconText
	if toastType == "error" then
		backgroundColor = Color3.new(0.6, 0.1, 0.1)
		iconText = "X"
	elseif toastType == "warning" then
		backgroundColor = Color3.new(0.7, 0.5, 0)
		iconText = "âš "
	elseif toastType == "success" then
		backgroundColor = Color3.new(0.1, 0.6, 0.1)
		iconText = "Y"
	else
		backgroundColor = Color3.new(0.1, 0.3, 0.6)
		iconText = "â„¹"
	end

	local iconBg = Instance.new("Frame")
	iconBg.Size = UDim2.new(0, 50, 0, 50)
	iconBg.Position = UDim2.new(0, 10, 0.5, -25)
	iconBg.BackgroundColor3 = backgroundColor
	iconBg.BorderSizePixel = 0
	iconBg.Parent = mainFrame

	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(1, 0, 1, 0)
	icon.Text = iconText
	icon.TextColor3 = Color3.new(1, 1, 1)
	icon.Font = Enum.Font.ArialBold
	icon.TextSize = 24
	icon.BackgroundTransparency = 1
	icon.Parent = iconBg

	local messageContainer = Instance.new("Frame")
	messageContainer.Size = UDim2.new(1, -80, 1, -20)
	messageContainer.Position = UDim2.new(0, 70, 0, 10)
	messageContainer.BackgroundTransparency = 1
	messageContainer.Parent = mainFrame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, 0, 1, 0)
	messageLabel.Text = messageText or ""
	messageLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9)
	messageLabel.Font = Enum.Font.Arial
	messageLabel.TextSize = 14
	messageLabel.TextWrapped = true
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.BackgroundTransparency = 1
	messageLabel.Parent = messageContainer

	local progressBar = Instance.new("Frame")
	progressBar.Size = UDim2.new(1, 0, 0, 3)
	progressBar.Position = UDim2.new(0, 0, 1, -3)
	progressBar.BackgroundColor3 = backgroundColor
	progressBar.BorderSizePixel = 0
	progressBar.Parent = mainFrame

	gui.Parent = parent

	mainFrame.Position = UDim2.new(0.5, -175, 1, 0)

	spawn(function()
		
		for i = 1, 20 do
			mainFrame.Position = UDim2.new(0.5, -175, 1 - (i * 0.0075), 0)
			wait(0.01)
		end

		local startTime = tick()
		local endTime = startTime + duration

		while tick() < endTime and gui.Parent do
			local elapsed = tick() - startTime
			local progress = elapsed / duration
			progressBar.Size = UDim2.new(1 - progress, 0, 0, 3)
			wait(0.05)
		end

		for i = 1, 20 do
			mainFrame.Position = UDim2.new(0.5, -175, 0.85 + (i * 0.0075), 0)
			wait(0.01)
		end

		if gui.Parent then
			gui:Destroy()
		end
	end)

	return gui
end

local function createAlertGui(parent, title, messageText, duration, alertType)
	if not parent or not parent:IsA("PlayerGui") then return nil end

	duration = duration or 5
	alertType = alertType or "info"

	for _, gui in ipairs(parent:GetChildren()) do
		if gui:IsA("ScreenGui") and gui.Name == "AdminAlertGUI" then
			gui:Destroy()
		end
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = "Admin"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true

	local overlay = Instance.new("Frame")
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.BackgroundColor3 = Color3.new(0, 0, 0)
	overlay.BackgroundTransparency = 0.5
	overlay.BorderSizePixel = 0
	overlay.Parent = gui

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0, 400, 0, 250)
	mainFrame.Position = UDim2.new(0.5, -200, 0.5, -125)
	mainFrame.BackgroundColor3 = Color3.new(0.15, 0.15, 0.2)
	mainFrame.BorderSizePixel = 2
	mainFrame.BorderColor3 = Color3.new(0.3, 0.3, 0.4)
	mainFrame.Parent = gui

	local titleBar = Instance.new("Frame")
	titleBar.Size = UDim2.new(1, 0, 0, 40)

	if alertType == "warning" then
		titleBar.BackgroundColor3 = Color3.new(0.7, 0.5, 0)
	elseif alertType == "error" then
		titleBar.BackgroundColor3 = Color3.new(0.7, 0.2, 0.2)
	else
		titleBar.BackgroundColor3 = Color3.new(0.2, 0.4, 0.7)
	end

	titleBar.BorderSizePixel = 0
	titleBar.Parent = mainFrame

	local icon = Instance.new("TextLabel")
	icon.Size = UDim2.new(0, 30, 0, 30)
	icon.Position = UDim2.new(0, 10, 0.5, -15)
	icon.Font = Enum.Font.ArialBold
	icon.TextSize = 20
	icon.BackgroundTransparency = 1
	icon.TextColor3 = Color3.new(1, 1, 1)
	icon.Parent = titleBar

	if alertType == "warning" then
		icon.Text = "âš "
	elseif alertType == "error" then
		icon.Text = "X"
	else
		icon.Text = "â„¹"
	end

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -50, 1, 0)
	titleLabel.Position = UDim2.new(0, 50, 0, 0)
	titleLabel.Text = title or "Alert"
	titleLabel.TextColor3 = Color3.new(1, 1, 1)
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.TextSize = 18
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.BackgroundTransparency = 1
	titleLabel.Parent = titleBar

	local messageFrame = Instance.new("Frame")
	messageFrame.Size = UDim2.new(1, -20, 1, -80)
	messageFrame.Position = UDim2.new(0, 10, 0, 50)
	messageFrame.BackgroundTransparency = 1
	messageFrame.Parent = mainFrame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, 0, 1, 0)
	messageLabel.Text = messageText or ""
	messageLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9)
	messageLabel.Font = Enum.Font.Arial
	messageLabel.TextSize = 14
	messageLabel.TextWrapped = true
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.BackgroundTransparency = 1
	messageLabel.Parent = messageFrame

	local okButton = Instance.new("TextButton")
	okButton.Size = UDim2.new(0, 100, 0, 30)
	okButton.Position = UDim2.new(0.5, -50, 1, -40)
	okButton.Text = "OK"
	okButton.TextColor3 = Color3.new(1, 1, 1)
	okButton.Font = Enum.Font.ArialBold
	okButton.TextSize = 14

	if alertType == "warning" then
		okButton.BackgroundColor3 = Color3.new(0.8, 0.6, 0)
	elseif alertType == "error" then
		okButton.BackgroundColor3 = Color3.new(0.8, 0.3, 0.3)
	else
		okButton.BackgroundColor3 = Color3.new(0.3, 0.5, 0.8)
	end

	okButton.BorderSizePixel = 0
	okButton.Parent = mainFrame

	okButton.MouseEnter:Connect(function()
		okButton.BackgroundColor3 = okButton.BackgroundColor3:Lerp(Color3.new(1, 1, 1), 0.1)
	end)

	okButton.MouseLeave:Connect(function()
		if alertType == "warning" then
			okButton.BackgroundColor3 = Color3.new(0.8, 0.6, 0)
		elseif alertType == "error" then
			okButton.BackgroundColor3 = Color3.new(0.8, 0.3, 0.3)
		else
			okButton.BackgroundColor3 = Color3.new(0.3, 0.5, 0.8)
		end
	end)

	okButton.MouseButton1Click:Connect(function()
		gui:Destroy()
	end)

	gui.Parent = parent

	spawn(function()
		wait(duration)
		if gui.Parent then
			gui:Destroy()
		end
	end)

	return gui
end

local function message(title, msg, players, duration, messageType)
	if not players or #players == 0 then return end
	duration = duration or 5
	messageType = messageType or "info"

	for _, plr in ipairs(players) do
		if plr and plr:IsA("Player") then
			local success, err = pcall(function()
				local playerGui = plr:FindFirstChild("PlayerGui")
				if playerGui then
					createMessageGui(playerGui, title, msg, duration, messageType)
				end
			end)
			if not success then
				warn("Failed to send message to " .. plr.Name .. ": " .. err)
			end
		end
	end
end

local function hint(msg, players, duration)
	if not players or #players == 0 then return end
	duration = duration or 3

	for _, plr in ipairs(players) do
		if plr and plr:IsA("Player") then
			local success, err = pcall(function()
				local playerGui = plr:FindFirstChild("PlayerGui")
				if playerGui then
					createHintGui(playerGui, msg, duration)
				end
			end)
			if not success then
				warn("Failed to send hint to " .. plr.Name .. ": " .. err)
			end
		end
	end
end

local function toast(msg, players, duration, toastType)
	if not players or #players == 0 then return end
	duration = duration or 3
	toastType = toastType or "info"

	for _, plr in ipairs(players) do
		if plr and plr:IsA("Player") then
			local success, err = pcall(function()
				local playerGui = plr:FindFirstChild("PlayerGui")
				if playerGui then
					createToastGui(playerGui, msg, duration, toastType)
				end
			end)
			if not success then
				warn("Failed to send toast to " .. plr.Name .. ": " .. err)
			end
		end
	end
end

local function alert(title, msg, players, alertType)
	if not players or #players == 0 then return end
	alertType = alertType or "info"

	for _, plr in ipairs(players) do
		if plr and plr:IsA("Player") then
			local success, err = pcall(function()
				local playerGui = plr:FindFirstChild("PlayerGui")
				if playerGui then
					createAlertGui(playerGui, title, msg, 5, alertType)
				end
			end)
			if not success then
				warn("Failed to send alert to " .. plr.Name .. ": " .. err)
			end
		end
	end
end

game.Players.PlayerRemoving:Connect(function(player)
	if player then
		local playerName = player.Name
		rateLimit[playerName] = nil
		groupCache[player.UserId] = nil

		-- Clean up pending commands
		for cmdId, data in pairs(pendingCommands) do
			if data.player == player then
				pendingCommands[cmdId] = nil
			end
		end
	end
end)

spawn(function()
	while wait(60) do
		local now = tick()

		for name, data in pairs(rateLimit) do
			if now - data.time > 300 then
				rateLimit[name] = nil
			end
		end

		for cmdId, data in pairs(pendingCommands) do
			if now - data.time > 30 then
				pendingCommands[cmdId] = nil
			end
		end

		if #commandLogs > 100 then
			table.remove(commandLogs, 1)
		end
	end
end)
----------------------------
local function logCommand(plr, command, args)
	table.insert(commandLogs, {
		player = plr.Name,
		command = command,
		args = args,
		time = os.date("%Y-%m-%d %H:%M:%S")
	})
	if #commandLogs > 100 then
		table.remove(commandLogs, 1)
	end
end

local commands = {}

commands["kick"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !kick [player] [reason]", {plr}, 3, "error")
		return 
	end

	local targets = getPlayers(plr, args[1])
	if #targets == 0 then
		toast("No player found: " .. args[1], {plr}, 3, "warning")
		return
	end

	for _, target in pairs(targets) do
		if target ~= plr and not isOwner(target.Name) then
			local reason = table.concat(args, " ", 2) or "Kicked by "..plr.Name
			toast("Kicked "..target.Name..": "..reason, {plr}, 3, "success")
			target:Kick(reason)
		else
			toast("Cannot kick "..target.Name, {plr}, 3, "warning")
		end
	end
end

commands["ban"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !ban [player] [reason]", {plr}, 3, "error")
		return 
	end

	local targets = getPlayers(plr, args[1])
	if #targets == 0 then
		toast("No player found: " .. args[1], {plr}, 3, "warning")
		return
	end

	for _, target in pairs(targets) do
		if not isOwner(target.Name) then
			table.insert(bannedPlayers, target.Name)
			local reason = table.concat(args, " ", 2) or "Banned by "..plr.Name
			toast("Banned "..target.Name, {plr}, 3, "success")
			target:Kick(reason)
		else
			toast("Cannot ban "..target.Name, {plr}, 3, "warning")
		end
	end
end

commands["unban"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !unban [player]", {plr}, 3, "error")
		return 
	end

	local targetName = args[1]:lower()
	for i, name in pairs(bannedPlayers) do
		if name:lower() == targetName then
			table.remove(bannedPlayers, i)
			toast("Unbanned "..targetName, {plr}, 3, "success")
			return
		end
	end
	toast("Player not found in ban list: "..args[1], {plr}, 3, "warning")
end

commands["mute"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !mute [player]", {plr}, 3, "error")
		return 
	end

	local targets = getPlayers(plr, args[1])
	if #targets == 0 then
		toast("No player found: " .. args[1], {plr}, 3, "warning")
		return
	end

	for _, target in pairs(targets) do
		if not isOwner(target.Name) then
			table.insert(mutedPlayers, target.Name)
			toast("Muted "..target.Name, {plr}, 3, "success")
			hint("You have been muted by "..plr.Name, {target}, 5)
		else
			toast("Cannot mute "..target.Name, {plr}, 3, "warning")
		end
	end
end

commands["unmute"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !unmute [player]", {plr}, 3, "error")
		return 
	end

	local targetName = args[1]:lower()
	for i, name in pairs(mutedPlayers) do
		if name:lower() == targetName then
			table.remove(mutedPlayers, i)
			toast("Unmuted "..targetName, {plr}, 3, "success")
			return
		end
	end
	toast("Player not found in mute list: "..args[1], {plr}, 3, "warning")
end

commands["freeze"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "all")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.Anchored = true
				end
			end
			toast("Froze "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["thaw"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "all")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.Anchored = false
				end
			end
			toast("Unfroze "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["respawn"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			target.Character:BreakJoints()
			toast("Respawned "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["heal"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.Health = humanoid.MaxHealth
				toast("Healed "..target.Name, {plr}, 3, "success")
			end
		end
	end
end

commands["kill"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "random")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.Health = 0
				toast("Killed "..target.Name, {plr}, 3, "warning")
			end
		end
	end
end

commands["god"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.MaxHealth = math.huge
				humanoid.Health = math.huge
				toast("God mode enabled for "..target.Name, {plr}, 3, "success")
			end
		end
	end
end

commands["ungod"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.MaxHealth = 100
				humanoid.Health = 100
				toast("God mode disabled for "..target.Name, {plr}, 3, "success")
			end
		end
	end
end

commands["jail"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !jail [player]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local jail = Instance.new("Part")
			jail.Name = "Jail_"..target.Name
			jail.Size = Vector3.new(10, 10, 10)
			jail.Position = target.Character.HumanoidRootPart.Position + Vector3.new(0, 5, 0)
			jail.Anchored = true
			jail.CanCollide = true
			jail.Transparency = 0.5
			jail.BrickColor = BrickColor.new("Bright blue")
			jail.Parent = workspace
			target.Character.HumanoidRootPart.CFrame = CFrame.new(jail.Position)
			toast("Jailed "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["unjail"] = function(plr, args)
	for _, obj in pairs(workspace:GetChildren()) do
		if obj.Name:find("Jail_") then
			obj:Destroy()
		end
	end
	toast("All jails removed", {plr}, 3, "success")
end

commands["invisible"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end
			toast("Made "..target.Name.." invisible", {plr}, 3, "success")
		end
	end
end

commands["visible"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.Transparency = 0
				end
			end
			toast("Made "..target.Name.." visible", {plr}, 3, "success")
		end
	end
end

commands["ghost"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
					part.Transparency = 0.5
				end
			end
			toast("Made "..target.Name.." a ghost", {plr}, 3, "success")
		end
	end
end

commands["unghost"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
					part.Transparency = 0
				end
			end
			toast("Removed ghost effect from "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["sit"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.Sit = true
				toast("Made "..target.Name.." sit", {plr}, 3, "success")
			end
		end
	end
end

commands["unsit"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.Sit = false
				toast("Made "..target.Name.." stand up", {plr}, 3, "success")
			end
		end
	end
end

commands["float"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.PlatformStand = true
				toast("Made "..target.Name.." float", {plr}, 3, "success")
			end
		end
	end
end

commands["unfloat"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.PlatformStand = false
				toast("Stopped "..target.Name.." from floating", {plr}, 3, "success")
			end
		end
	end
end

commands["warn"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !warn [player] [reason]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if not warnings[target.Name] then warnings[target.Name] = 0 end
		warnings[target.Name] = warnings[target.Name] + 1
		local reason = table.concat(args, " ", 2) or "No reason given"
		alert("WARNING", "You have been warned by "..plr.Name.."\nReason: "..reason.."\n\nWarnings: "..warnings[target.Name].."/3", {target}, "warning")
		toast("Warned "..target.Name.." ("..warnings[target.Name].."/3)", {plr}, 3, "warning")

		if warnings[target.Name] >= 3 then
			target:Kick("Too many warnings (3/3)")
			toast("Kicked "..target.Name.." for reaching 3 warnings", {plr}, 3, "error")
			warnings[target.Name] = nil
		end
	end
end

commands["warnings"] = function(plr, args)
	if not warnings or next(warnings) == nil then
		message("Warnings", "No warnings have been issued yet.", {plr})
		return
	end

	local msg = "Player Warnings:\n\n"
	for player, count in pairs(warnings) do
		msg = msg .. player .. ": " .. count .. "/3\n"
	end
	message("Warning List", msg, {plr})
end

commands["clearwarnings"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !clearwarnings [player]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		warnings[target.Name] = nil
		toast("Cleared warnings for "..target.Name, {plr}, 3, "success")
	end
end

commands["health"] = function(plr, args)
	if #args < 2 then 
		toast("Usage: !health [player] [amount]", {plr}, 3, "error")
		return 
	end

	local amount = tonumber(args[2])
	if not amount then
		toast("Invalid health amount", {plr}, 3, "error")
		return
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.MaxHealth = amount
				humanoid.Health = amount
				toast("Set "..target.Name.." health to "..amount, {plr}, 3, "success")
			end
		end
	end
end

commands["maxhealth"] = function(plr, args)
	if #args < 2 then 
		toast("Usage: !maxhealth [player] [amount]", {plr}, 3, "error")
		return 
	end

	local amount = tonumber(args[2])
	if not amount then
		toast("Invalid max health amount", {plr}, 3, "error")
		return
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.MaxHealth = amount
				toast("Set "..target.Name.." max health to "..amount, {plr}, 3, "success")
			end
		end
	end
end

commands["clone"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local clone = target.Character:Clone()
			clone.Parent = workspace
			clone:MoveTo(target.Character.HumanoidRootPart.Position + Vector3.new(5, 0, 0))
			toast("Cloned "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["noclip"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
				end
			end
			toast("Noclip enabled for "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["clip"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
			toast("Noclip disabled for "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["ff"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local ff = Instance.new("ForceField")
			ff.Parent = target.Character
			toast("ForceField added to "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["unff"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, item in pairs(target.Character:GetChildren()) do
				if item:IsA("ForceField") then
					item:Destroy()
				end
			end
			toast("ForceField removed from "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["sparkle"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					local sparkles = Instance.new("Sparkles")
					sparkles.Parent = part
				end
			end
			toast("Added sparkles to "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["unsparkle"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					for _, effect in pairs(part:GetChildren()) do
						if effect:IsA("Sparkles") then
							effect:Destroy()
						end
					end
				end
			end
			toast("Removed sparkles from "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["fire"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					local fire = Instance.new("Fire")
					fire.Parent = part
				end
			end
			toast("Added fire to "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["unfire"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					for _, effect in pairs(part:GetChildren()) do
						if effect:IsA("Fire") then
							effect:Destroy()
						end
					end
				end
			end
			toast("Removed fire from "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["smoke"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					local smoke = Instance.new("Smoke")
					smoke.Parent = part
				end
			end
			toast("Added smoke to "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["unsmoke"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					for _, effect in pairs(part:GetChildren()) do
						if effect:IsA("Smoke") then
							effect:Destroy()
						end
					end
				end
			end
			toast("Removed smoke from "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["shutdown"] = function(plr, args)
	alert(
		"SERVER SHUTDOWN",
		"The server is shutting down in 5 seconds...\n\nInitiated by: " .. plr.Name,
		game.Players:GetPlayers(),
		"error"
	)

	task.wait(5)

	for _, player in ipairs(game.Players:GetPlayers()) do
		player:Kick("Server shutdown by " .. plr.Name)
	end

	toast("Server shutdown complete", { plr }, 3, "error")

	game:Shutdown() -- MUST be inside the function
end

commands["rejoin"] = function(plr, args)
	toast("Rejoining server...", {plr}, 3, "info")
	game:GetService("TeleportService"):Teleport(game.PlaceId, plr)
end

commands["clear"] = function(plr, args)
	local count = 0
	for _, obj in pairs(workspace:GetChildren()) do
		if not obj:IsA("Terrain") and not obj:IsA("Camera") and obj ~= plr.Character then
			obj:Destroy()
			count = count + 1
		end
	end
	toast("Cleared "..count.." objects", {plr}, 3, "success")
end

commands["time"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !time [hour 0-24]", {plr}, 3, "error")
		return 
	end

	local hour = tonumber(args[1])
	if hour and hour >= 0 and hour <= 24 then
		game:GetService("Lighting").ClockTime = hour
		toast("Set time to "..hour..":00", {plr}, 3, "success")
	else
		toast("Invalid time (0-24)", {plr}, 3, "error")
	end
end

commands["ambient"] = function(plr, args)
	if #args < 3 then 
		toast("Usage: !ambient [R 0-1] [G 0-1] [B 0-1]", {plr}, 3, "error")
		return 
	end

	local r, g, b = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
	if r and g and b then
		game:GetService("Lighting").Ambient = Color3.new(r, g, b)
		toast("Set ambient color to "..r..", "..g..", "..b, {plr}, 3, "success")
	else
		toast("Invalid color values", {plr}, 3, "error")
	end
end

commands["brightness"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !brightness [value 0-10]", {plr}, 3, "error")
		return 
	end

	local brightness = tonumber(args[1])
	if brightness then
		game:GetService("Lighting").Brightness = brightness
		toast("Set brightness to "..brightness, {plr}, 3, "success")
	else
		toast("Invalid brightness value", {plr}, 3, "error")
	end
end

commands["fog"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !fog [distance]", {plr}, 3, "error")
		return 
	end

	local distance = tonumber(args[1])
	if distance then
		game:GetService("Lighting").FogEnd = distance
		toast("Set fog distance to "..distance, {plr}, 3, "success")
	else
		toast("Invalid distance value", {plr}, 3, "error")
	end
end

commands["nofog"] = function(plr, args)
	game:GetService("Lighting").FogEnd = 100000
	toast("Fog removed", {plr}, 3, "success")
end

commands["gravity"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !gravity [value]", {plr}, 3, "error")
		return 
	end

	local gravity = tonumber(args[1])
	if gravity then
		workspace.Gravity = gravity
		toast("Set gravity to "..gravity, {plr}, 3, "success")
	else
		toast("Invalid gravity value", {plr}, 3, "error")
	end
end

commands["nogravity"] = function(plr, args)
	workspace.Gravity = 0
	toast("Gravity disabled", {plr}, 3, "success")
end

commands["normalgravity"] = function(plr, args)
	workspace.Gravity = 196.2
	toast("Gravity set to normal (196.2)", {plr}, 3, "success")
end

commands["message"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !message [text]", {plr}, 3, "error")
		return 
	end

	local text = table.concat(args, " ")
	message("Message from "..plr.Name, text, game.Players:GetPlayers(), 5, "info")
	toast("Message sent to all players", {plr}, 3, "success")
end

commands["hint"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !hint [text]", {plr}, 3, "error")
		return 
	end

	local text = table.concat(args, " ")
	hint(text, game.Players:GetPlayers(), 5)
	toast("Hint sent to all players", {plr}, 3, "success")
end

commands["announce"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !announce [text]", {plr}, 3, "error")
		return 
	end

	local text = table.concat(args, " ")
	message("ANNOUNCEMENT", text, game.Players:GetPlayers(), 10, "warning")
	toast("Announcement sent to all players", {plr}, 3, "success")
end

commands["alert"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !alert [text]", {plr}, 3, "error")
		return 
	end

	local text = table.concat(args, " ")
	alert("ALERT", text, game.Players:GetPlayers(), "error")
	toast("Alert sent to all players", {plr}, 3, "success")
end

commands["maxplayers"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !maxplayers [number]", {plr}, 3, "error")
		return 
	end

	local max = tonumber(args[1])
	if max then
		game.Players.MaxPlayers = max
		toast("Max players set to "..max, {plr}, 3, "success")
	else
		toast("Invalid number", {plr}, 3, "error")
	end
end

commands["resetlighting"] = function(plr, args)
	game:GetService("Lighting"):ClearAllChildren()
	toast("Lighting reset", {plr}, 3, "success")
end

commands["resetworkspace"] = function(plr, args)
	local count = 0
	for _, obj in pairs(workspace:GetChildren()) do
		if not obj:IsA("Terrain") and not obj:IsA("Camera") and not obj:IsA("BasePlayer") then
			obj:Destroy()
			count = count + 1
		end
	end
	toast("Workspace reset ("..count.." objects removed)", {plr}, 3, "success")
end

commands["lock"] = function(plr, args)
	game.Players.PlayerAdded:Connect(function(newPlayer)
		newPlayer:Kick("Server is locked")
	end)
	message("SERVER LOCKED", "The server has been locked by "..plr.Name.."\nNo new players can join.", game.Players:GetPlayers(), 5, "warning")
	toast("Server locked", {plr}, 3, "success")
end

commands["unlock"] = function(plr, args)
	hint("Server unlocked", game.Players:GetPlayers(), 3)
	toast("Server unlocked", {plr}, 3, "success")
end

commands["fly"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")

	for _, target in pairs(targets) do
		local char = target.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		local hum = char and char:FindFirstChildOfClass("Humanoid")

		if hrp and hum and not hrp:FindFirstChild("FlyVelocity") then
			hum.PlatformStand = true

			local bv = Instance.new("BodyVelocity")
			bv.Name = "FlyVelocity"
			bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
			bv.Velocity = Vector3.zero
			bv.Parent = hrp

			local bg = Instance.new("BodyGyro")
			bg.Name = "FlyGyro"
			bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
			bg.P = 9e4
			bg.CFrame = hrp.CFrame
			bg.Parent = hrp

			task.spawn(function()
				while bv.Parent and hum.Health > 0 do
					local cam = workspace.CurrentCamera
					if cam then
						bg.CFrame = cam.CFrame
						bv.Velocity = cam.CFrame.LookVector * 60
					end
					task.wait()
				end
			end)

			toast(target.Name .. " can now fly", {plr}, 3, "success")
		end
	end
end


commands["unfly"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")

	for _, target in pairs(targets) do
		local char = target.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		local hum = char and char:FindFirstChildOfClass("Humanoid")

		if hrp then
			if hrp:FindFirstChild("FlyVelocity") then
				hrp.FlyVelocity:Destroy()
			end
			if hrp:FindFirstChild("FlyGyro") then
				hrp.FlyGyro:Destroy()
			end
		end

		if hum then
			hum.PlatformStand = false
		end

		toast("Flying disabled for " .. target.Name, {plr}, 3, "success")
	end
end


commands["spin"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
			bodyAngularVelocity.AngularVelocity = Vector3.new(0, 20, 0)
			bodyAngularVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
			bodyAngularVelocity.Parent = target.Character.HumanoidRootPart
			toast(target.Name.." is now spinning", {plr}, 3, "success")
		end
	end
end

commands["unspin"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			for _, obj in pairs(target.Character.HumanoidRootPart:GetChildren()) do
				if obj:IsA("BodyAngularVelocity") then
					obj:Destroy()
				end
			end
			toast("Stopped "..target.Name.." from spinning", {plr}, 3, "success")
		end
	end
end

commands["size"] = function(plr, args)
	if #args < 2 then 
		toast("Usage: !size [player] [scale]", {plr}, 3, "error")
		return 
	end

	local scale = tonumber(args[2])
	if not scale then
		toast("Invalid scale number", {plr}, 3, "error")
		return
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.Size = part.Size * scale
				end
			end
			toast("Scaled "..target.Name.." by "..scale.."x", {plr}, 3, "success")
		end
	end
end

commands["normalize"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			-- Reset to default humanoid size
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					if part.Name == "Head" then
						part.Size = Vector3.new(2, 1, 1)
					elseif part.Name:find("Arm") or part.Name:find("Leg") then
						part.Size = Vector3.new(1, 2, 1)
					elseif part.Name == "Torso" then
						part.Size = Vector3.new(2, 2, 1)
					end
				end
			end
			toast("Normalized "..target.Name.." size", {plr}, 3, "success")
		end
	end
end

commands["speed"] = function(plr, args)
	if #args < 2 then 
		toast("Usage: !speed [player] [value]", {plr}, 3, "error")
		return 
	end

	local speed = tonumber(args[2])
	if not speed then
		toast("Invalid speed number", {plr}, 3, "error")
		return
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = speed
				toast("Set "..target.Name.." speed to "..speed, {plr}, 3, "success")
			end
		end
	end
end

commands["jump"] = function(plr, args)
	if #args < 2 then 
		toast("Usage: !jump [player] [power]", {plr}, 3, "error")
		return 
	end

	local power = tonumber(args[2])
	if not power then
		toast("Invalid jump power number", {plr}, 3, "error")
		return
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.JumpPower = power
				toast("Set "..target.Name.." jump power to "..power, {plr}, 3, "success")
			end
		end
	end
end

commands["normalwalkspeed"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = 16
				toast("Reset "..target.Name.." walk speed to normal (16)", {plr}, 3, "success")
			end
		end
	end
end

commands["normaljumppower"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoid.JumpPower = 50
				toast("Reset "..target.Name.." jump power to normal (50)", {plr}, 3, "success")
			end
		end
	end
end

commands["color"] = function(plr, args)
	if #args < 4 then 
		toast("Usage: !color [player] [R 0-255] [G 0-255] [B 0-255]", {plr}, 3, "error")
		return 
	end

	local r, g, b = tonumber(args[2]), tonumber(args[3]), tonumber(args[4])
	if not r or not g or not b then
		toast("Invalid color values", {plr}, 3, "error")
		return
	end

	-- Convert 0-255 to 0-1
	r, g, b = r/255, g/255, b/255

	for _, target in pairs(getPlayers(plr, args[1])) do
		if target.Character then
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.BrickColor = BrickColor.new(Color3.new(r, g, b))
				end
			end
			toast("Colored "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["randomcolor"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			local randomColor = BrickColor.Random()
			for _, part in pairs(target.Character:GetChildren()) do
				if part:IsA("BasePart") then
					part.BrickColor = randomColor
				end
			end
			toast("Random color applied to "..target.Name, {plr}, 3, "success")
		end
	end
end

commands["rainbow"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character then
			spawn(function()
				toast("Rainbow effect started for "..target.Name, {plr}, 3, "success")
				while target and target.Character and target.Parent do
					for _, part in pairs(target.Character:GetChildren()) do
						if part:IsA("BasePart") then
							local hue = tick() % 5 / 5
							part.BrickColor = BrickColor.new(Color3.fromHSV(hue, 1, 1))
						end
					end
					wait(0.1)
				end
			end)
		end
	end
end

commands["party"] = function(plr, args)
	for i = 1, 50 do
		local part = Instance.new("Part")
		part.Size = Vector3.new(2,2,2)
		part.Position = Vector3.new(math.random(-50,50), math.random(10,50), math.random(-50,50))
		part.BrickColor = BrickColor.Random()
		part.Anchored = false
		part.CanCollide = true
		part.Parent = workspace
	end
	toast("Party started! 50 colorful parts spawned.", {plr}, 3, "success")
end

commands["rocket"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.Velocity = Vector3.new(0, 100, 0)
			bodyVelocity.MaxForce = Vector3.new(0, math.huge, 0)
			bodyVelocity.Parent = target.Character.HumanoidRootPart
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
			toast("Launched "..target.Name.." like a rocket!", {plr}, 3, "success")
		end
	end
end

commands["explode"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			local explosion = Instance.new("Explosion")
			explosion.Position = target.Character.HumanoidRootPart.Position
			explosion.BlastPressure = 0
			explosion.Parent = workspace
			toast("Exploded "..target.Name, {plr}, 3, "success")
		end
	end
end

-- === TELEPORTATION ===
commands["tp"] = function(plr, args)
	if #args < 2 then 
		toast("Usage: !tp [player] [destination]", {plr}, 3, "error")
		return 
	end

	local targets = getPlayers(plr, args[1])
	local destination = getPlayers(plr, args[2])[1]

	if destination and destination.Character and destination.Character:FindFirstChild("HumanoidRootPart") then
		for _, target in pairs(targets) do
			if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
				target.Character.HumanoidRootPart.CFrame = destination.Character.HumanoidRootPart.CFrame
				toast("Teleported "..target.Name.." to "..destination.Name, {plr}, 3, "success")
			end
		end
	else
		toast("Destination not found", {plr}, 3, "error")
	end
end

commands["to"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !to [player]", {plr}, 3, "error")
		return 
	end

	local target = getPlayers(plr, args[1])[1]
	if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") and
		plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		plr.Character.HumanoidRootPart.CFrame = target.Character.HumanoidRootPart.CFrame
		toast("Teleported to "..target.Name, {plr}, 3, "success")
	else
		toast("Target not found", {plr}, 3, "error")
	end
end

commands["bring"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !bring [player]", {plr}, 3, "error")
		return 
	end

	local targets = getPlayers(plr, args[1])
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		for _, target in pairs(targets) do
			if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
				target.Character.HumanoidRootPart.CFrame = plr.Character.HumanoidRootPart.CFrame
				toast("Brought "..target.Name.." to you", {plr}, 3, "success")
			end
		end
	else
		toast("You need a character to use this command", {plr}, 3, "error")
	end
end

commands["tppos"] = function(plr, args)
	if #args < 3 then 
		toast("Usage: !tppos [x] [y] [z]", {plr}, 3, "error")
		return 
	end

	local x, y, z = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
	if x and y and z and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		plr.Character.HumanoidRootPart.CFrame = CFrame.new(x, y, z)
		toast("Teleported to position: "..x..", "..y..", "..z, {plr}, 3, "success")
	else
		toast("Invalid coordinates", {plr}, 3, "error")
	end
end

commands["tpmouse"] = function(plr, args)
	if plr:GetMouse().Target and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		plr.Character.HumanoidRootPart.CFrame = plr:GetMouse().Hit + Vector3.new(0, 5, 0)
		toast("Teleported to mouse position", {plr}, 3, "success")
	else
		toast("No target under mouse", {plr}, 3, "error")
	end
end

commands["sky"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			target.Character.HumanoidRootPart.CFrame = target.Character.HumanoidRootPart.CFrame + Vector3.new(0, 500, 0)
			toast("Sent "..target.Name.." to the sky", {plr}, 3, "success")
		end
	end
end

commands["void"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			target.Character.HumanoidRootPart.CFrame = CFrame.new(0, -500, 0)
			toast("Sent "..target.Name.." to the void", {plr}, 3, "success")
		end
	end
end

commands["center"] = function(plr, args)
	local targets = getPlayers(plr, args[1] or "me")
	for _, target in pairs(targets) do
		if target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
			target.Character.HumanoidRootPart.CFrame = CFrame.new(0, 5, 0)
			toast("Sent "..target.Name.." to center", {plr}, 3, "success")
		end
	end
end

commands["promote"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !promote [player]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if not isAdmin(target.Name) then
			table.insert(admins, target.Name)
			message("Admin Promotion", "You have been promoted to Admin by "..plr.Name, {target}, 5, "success")
			toast("Promoted "..target.Name.." to Admin", {plr}, 3, "success")
		else
			toast(target.Name.." is already an admin", {plr}, 3, "warning")
		end
	end
end


-- === MUSIC COMMANDS ===
commands["music"] = function(plr, args)
	if not args or #args < 1 then 
		toast("Usage: !music [id] or !music stop", {plr}, 3, "error")
		return 
	end

	if args[1]:lower() == "stop" then
		for _, sound in pairs(workspace:GetDescendants()) do
			if sound:IsA("Sound") and sound.Name == "AdminMusic" then
				sound:Stop()
				sound:Destroy()
			end
		end
		toast("Music stopped", {plr}, 3, "success")
		return
	end

	local soundId = tonumber(args[1])
	if not soundId then
		toast("Invalid sound ID", {plr}, 3, "error")
		return
	end

	local sound = Instance.new("Sound")
	sound.Name = "AdminMusic"
	sound.SoundId = "rbxassetid://" .. soundId
	sound.Volume = 0.5
	sound.Looped = true
	sound.Parent = workspace

	local success, err = pcall(function()
		sound:Play()
	end)

	if success then
		toast("Playing music ID: " .. soundId, {plr}, 3, "success")
	else
		sound:Destroy()
		toast("Failed to play sound: " .. tostring(err), {plr}, 3, "error")
	end
end

commands["volume"] = function(plr, args)
	if not args or #args < 1 then 
		toast("Usage: !volume [0-10]", {plr}, 3, "error")
		return 
	end

	local volume = tonumber(args[1])
	if not volume or volume < 0 or volume > 10 then
		toast("Volume must be between 0 and 10", {plr}, 3, "error")
		return
	end

	for _, sound in pairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.Name == "AdminMusic" then
			sound.Volume = volume
		end
	end
	toast("Volume set to " .. volume, {plr}, 3, "success")
end

commands["play"] = function(plr, args)
	commands["music"](plr, args)
end

commands["stopmusic"] = function(plr, args)
	for _, sound in pairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.Name == "AdminMusic" then
			sound:Stop()
			sound:Destroy()
		end
	end
	toast("All music stopped", {plr}, 3, "success")
end

commands["pause"] = function(plr, args)
	for _, sound in pairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.Name == "AdminMusic" then
			sound:Pause()
		end
	end
	toast("Music paused", {plr}, 3, "success")
end

commands["resume"] = function(plr, args)
	for _, sound in pairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.Name == "AdminMusic" then
			sound:Play()
		end
	end
	toast("Music resumed", {plr}, 3, "success")
end

commands["playfor"] = function(plr, args)
	if not args or #args < 2 then 
		toast("Usage: !playfor [player] [soundId]", {plr}, 3, "error")
		return 
	end

	local targetName = args[1]
	local soundId = tonumber(args[2])
	local targets = getPlayers(plr, targetName)

	if #targets == 0 then
		toast("No player found: " .. targetName, {plr}, 3, "error")
		return
	end

	if not soundId then
		toast("Invalid sound ID", {plr}, 3, "error")
		return
	end

	for _, target in pairs(targets) do
		if target and target:IsA("Player") then
		
			for _, sound in pairs(target:GetDescendants()) do
				if sound:IsA("Sound") and sound.Name == "PlayerMusic" then
					sound:Destroy()
				end
			end

			local sound = Instance.new("Sound")
			sound.Name = "PlayerMusic"
			sound.SoundId = "rbxassetid://" .. soundId
			sound.Volume = 0.5
			sound.Looped = true

			if target:FindFirstChild("Backpack") then
				sound.Parent = target.Backpack
			elseif target.Character then
				sound.Parent = target.Character
			else
				sound.Parent = target
			end

			local success, err = pcall(function()
				sound:Play()
			end)

			if success then
				toast("Playing music for " .. target.Name, {plr}, 3, "success")
			else
				sound:Destroy()
				toast("Failed to play for " .. target.Name, {plr}, 3, "error")
			end
		end
	end
end

commands["stopfor"] = function(plr, args)
	if not args or #args < 1 then 
		toast("Usage: !stopfor [player]", {plr}, 3, "error")
		return 
	end

	local targets = getPlayers(plr, args[1])
	for _, target in pairs(targets) do
		if target and target:IsA("Player") then
			for _, sound in pairs(target:GetDescendants()) do
				if sound:IsA("Sound") and sound.Name == "PlayerMusic" then
					sound:Stop()
					sound:Destroy()
				end
			end
		end
	end
	toast("Stopped music for player(s)", {plr}, 3, "success")
end

commands["ambient"] = function(plr, args)
	if not args or #args < 1 then 
		toast("Usage: !ambient [soundId] or !ambient stop", {plr}, 3, "error")
		return 
	end

	if args[1]:lower() == "stop" then
		local lighting = game:GetService("Lighting")
		for _, sound in pairs(lighting:GetChildren()) do
			if sound:IsA("Sound") and sound.Name == "AmbientMusic" then
				sound:Stop()
				sound:Destroy()
			end
		end
		toast("Ambient music stopped", {plr}, 3, "success")
		return
	end

	local soundId = tonumber(args[1])
	if not soundId then
		toast("Invalid sound ID", {plr}, 3, "error")
		return
	end

	local lighting = game:GetService("Lighting")

	for _, sound in pairs(lighting:GetChildren()) do
		if sound:IsA("Sound") and sound.Name == "AmbientMusic" then
			sound:Destroy()
		end
	end

	local sound = Instance.new("Sound")
	sound.Name = "AmbientMusic"
	sound.SoundId = "rbxassetid://" .. soundId
	sound.Volume = 0.3
	sound.Looped = true
	sound.Parent = lighting

	local success, err = pcall(function()
		sound:Play()
	end)

	if success then
		toast("Playing ambient music ID: " .. soundId, {plr}, 3, "success")
	else
		sound:Destroy()
		toast("Failed to play ambient sound: " .. tostring(err), {plr}, 3, "error")
	end
end

commands["musiclist"] = function(plr, args)
	local musicList = "Popular Music IDs:\n\n"
	musicList = musicList .. "142376088 - Megalovania\n"
	musicList = musicList .. "27697743 - Never Gonna Give You Up\n"
	musicList = musicList .. "184793429 - Wii Theme\n"
	musicList = musicList .. "137225025 - Caramelldansen\n"
	musicList = musicList .. "91163979 - Tokyo Drift\n"
	musicList = musicList .. "32957424 - Crab Rave\n"
	musicList = musicList .. "45987644 - Nyan Cat\n"
	musicList = musicList .. "45987645 - Rick Roll\n"
	musicList = musicList .. "27697229 - Shooting Stars\n"
	musicList = musicList .. "137226663 - All Star\n"
	musicList = musicList .. "91163981 - Take On Me\n"
	musicList = musicList .. "184792875 - Super Mario Bros\n"
	musicList = musicList .. "142536916 - Among Us Theme\n"
	musicList = musicList .. "32957590 - Giorno's Theme\n"
	musicList = musicList .. "45987646 - Roundabout\n\n"
	musicList = musicList .. "Usage: !music [id] or !play [id]\n"
	musicList = musicList .. "Stop: !music stop or !stopmusic"

	message("Music Library", musicList, {plr}, 20, "info")
end

commands["soundat"] = function(plr, args)
	if not args or #args < 2 then 
		toast("Usage: !soundat [soundId] [x] [y] [z]", {plr}, 3, "error")
		return 
	end

	local soundId = tonumber(args[1])
	if not soundId then
		toast("Invalid sound ID", {plr}, 3, "error")
		return
	end

	local x = tonumber(args[2]) or 0
	local y = tonumber(args[3]) or 0
	local z = tonumber(args[4]) or 0

	local sound = Instance.new("Sound")
	sound.Name = "PositionalSound"
	sound.SoundId = "rbxassetid://" .. soundId
	sound.Volume = 1.0
	sound.Looped = false
	sound.MaxDistance = 100
	sound.RollOffMode = Enum.RollOffMode.Linear

	local part = Instance.new("Part")
	part.Size = Vector3.new(1, 1, 1)
	part.Position = Vector3.new(x, y, z)
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = 1
	part.Name = "SoundEmitter_" .. soundId
	sound.Parent = part
	part.Parent = workspace

	local success, err = pcall(function()
		sound:Play()
	end)

	if success then
		toast("Playing sound at position: " .. x .. "," .. y .. "," .. z, {plr}, 3, "success")

		game:GetService("Debris"):AddItem(part, sound.TimeLength + 1)
	else
		part:Destroy()
		toast("Failed to play sound: " .. tostring(err), {plr}, 3, "error")
	end
end

commands["fade"] = function(plr, args)
	if not args or #args < 2 then 
		toast("Usage: !fade [time] [targetVolume]", {plr}, 3, "error")
		return 
	end

	local fadeTime = tonumber(args[1])
	local targetVolume = tonumber(args[2])

	if not fadeTime or not targetVolume then
		toast("Invalid fade parameters", {plr}, 3, "error")
		return
	end

	for _, sound in pairs(workspace:GetDescendants()) do
		if sound:IsA("Sound") and sound.Name == "AdminMusic" then
			local startVolume = sound.Volume
			local startTime = tick()

			coroutine.wrap(function()
				while tick() - startTime < fadeTime do
					local progress = (tick() - startTime) / fadeTime
					sound.Volume = startVolume + (targetVolume - startVolume) * progress
					wait(0.1)
				end
				sound.Volume = targetVolume
			end)()
		end
	end

	toast("Fading music to volume " .. targetVolume .. " over " .. fadeTime .. " seconds", {plr}, 3, "success")
end

local Players = game:GetService("Players")

-- Ban command by UserId only
commands["pcban"] = function(plr, args)
	if #args < 1 then
		toast("Usage: !pcban [userid] [reason]", {plr}, 3, "error")
		return
	end

	local userId = tonumber(args[1])
	if not userId then
		toast("Invalid UserId: " .. args[1], {plr}, 3, "error")
		return
	end

	local reason = table.concat(args, " ", 2)
	if reason == "" then
		reason = "Banned by admin"
	end

	local success, err = pcall(function()
		Players:BanAsync({
			UserIds = { userId },
			ApplyToUniverse = true,
			Duration = -1,
			DisplayReason = reason,
			PrivateReason = "Operator: " .. plr.Name .. " | " .. reason,
			ExcludeAltAccounts = false,
		})
	end)

	if success then
		toast("Permanently banned UserId: " .. userId .. " - " .. reason, {plr}, 3, "success")

		local onlinePlayer = Players:GetPlayerByUserId(userId)
		if onlinePlayer then
			onlinePlayer:Kick("You have been permanently banned.\nReason: " .. reason)
		end
	else
		toast("Ban failed: " .. tostring(err), {plr}, 3, "error")
	end
end

-- Unban command by UserId only
commands["pcunban"] = function(plr, args)
	if #args < 1 then
		toast("Usage: !pcunban [userid]", {plr}, 3, "error")
		return
	end

	local userId = tonumber(args[1])
	if not userId then
		toast("Invalid UserId: " .. args[1], {plr}, 3, "error")
		return
	end

	local success, err = pcall(function()
		Players:UnbanAsync({
			UserIds = { userId },
			ApplyToUniverse = true,
		})
	end)

	if success then
		toast("Successfully unbanned UserId: " .. userId, {plr}, 3, "success")
	else
		toast("Unban failed: " .. tostring(err), {plr}, 3, "error")
	end
end

commands["demote"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !demote [player]", {plr}, 3, "error")
		return 
	end

	local targetName = args[1]:lower()
	for i, name in pairs(admins) do
		if name:lower() == targetName then
			table.remove(admins, i)
			toast("Demoted "..targetName, {plr}, 3, "success")
			return
		end
	end
	toast("Player not found in admin list", {plr}, 3, "warning")
end

commands["tempadmin"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !tempadmin [player]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if not isAdmin(target.Name) then
			table.insert(tempAdmins, target.Name)
			message("Temporary Admin", "You have been given temporary admin powers by "..plr.Name, {target}, 5, "warning")
			toast("Gave temporary admin to "..target.Name, {plr}, 3, "success")
		else
			toast(target.Name.." is already an admin", {plr}, 3, "warning")
		end
	end
end

commands["mod"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !mod [player]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if not isMod(target.Name) then
			table.insert(mods, target.Name)
			message("Moderator", "You are now a Moderator!\nAdded by: "..plr.Name, {target}, 5, "info")
			toast("Made "..target.Name.." a moderator", {plr}, 3, "success")
		else
			toast(target.Name.." is already a moderator", {plr}, 3, "warning")
		end
	end
end

commands["unmod"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !unmod [player]", {plr}, 3, "error")
		return 
	end

	local targetName = args[1]:lower()
	for i, name in pairs(mods) do
		if name:lower() == targetName then
			table.remove(mods, i)
			toast("Removed moderator from "..targetName, {plr}, 3, "success")
			return
		end
	end
	toast("Player not found in moderator list", {plr}, 3, "warning")
end

commands["owner"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !owner [player]", {plr}, 3, "error")
		return 
	end

	for _, target in pairs(getPlayers(plr, args[1])) do
		if not isOwner(target.Name) then
			table.insert(owners, target.Name)
			message("Owner", "You are now an Owner!\nAdded by: "..plr.Name, {target}, 5, "success")
			toast("Made "..target.Name.." an owner", {plr}, 3, "success")
		else
			toast(target.Name.." is already an owner", {plr}, 3, "warning")
		end
	end
end

commands["cmds"] = function(plr, args)
	local categories = {
		"=== PLAYER MANAGEMENT ===",
		"!kick [player] [reason] - Kick a player",
		"!ban [player] [reason] - Ban a player",
		"!unban [player] - Unban a player",
		"!mute [player] - Mute a player",
		"!unmute [player] - Unmute a player",
		"!freeze [player] - Freeze a player",
		"!thaw [player] - Unfreeze a player",
		"!jail [player] - Jail a player",
		"!unjail - Remove all jails",
		"!respawn [player] - Respawn a player",
		"!heal [player] - Heal a player",
		"!kill [player] - Kill a player",
		"!god [player] - Make invincible",
		"!ungod [player] - Remove invincibility",
		"!invisible [player] - Make invisible",
		"!visible [player] - Make visible",
		"!ghost [player] - Ghost mode",
		"!unghost [player] - Normal mode",
		"",
		"=== SERVER CONTROL ===",
		"!shutdown - Shutdown server",
		"!clear - Clear workspace",
		"!time [hour] - Set time",
		"!gravity [value] - Set gravity",
		"!message [text] - Send message",
		"!hint [text] - Send hint",
		"!announce [text] - Announcement",
		"!alert [text] - Alert everyone",
		"!lock - Lock server",
		"!unlock - Unlock server",
		"",
		"=== FUN COMMANDS ===",
		"!fly [player] - Enable flying",
		"!unfly [player] - Disable flying",
		"!spin [player] - Spin player",
		"!unspin [player] - Stop spinning",
		"!size [player] [scale] - Resize",
		"!speed [player] [value] - Set speed",
		"!jump [player] [power] - Set jump",
		"!color [player] [r] [g] [b] - Color",
		"!randomcolor [player] - Random color",
		"!rainbow [player] - Rainbow effect",
		"!party - Spawn party objects",
		"!rocket [player] - Launch player",
		"!explode [player] - Create explosion",
		"",
		"=== TELEPORTATION ===",
		"!tp [player1] [player2] - Teleport",
		"!to [player] - Teleport to player",
		"!bring [player] - Bring player to you",
		"!tppos [x] [y] [z] - Teleport to coords",
		"!tpmouse - Teleport to mouse",
		"!sky [player] - Teleport to sky",
		"!void [player] - Teleport to void",
		"!center [player] - Teleport to center",
		"",
		"=== MUSIC & AUDIO ===",
		"!music [id] - Play music globally",
		"!music stop - Stop all music",
		"!volume [0-10] - Adjust music volume",
		"!play [id] - Alias for !music",
		"!stopmusic - Stop all music",
		"!pause - Pause music",
		"!resume - Resume music",
		"!playfor [player] [id] - Play for specific player",
		"!stopfor [player] - Stop music for player",
		"!ambient [id] - Play ambient music",
		"!ambient stop - Stop ambient music",
		"!musiclist - Show popular music IDs",
		"!soundat [id] [x] [y] [z] - Play sound at position",
		"!fade [time] [volume] - Fade music volume",
		"",
		"=== ADMIN MANAGEMENT ===",
		"!promote [player] - Promote to admin",
		"!demote [player] - Demote admin",
		"!tempadmin [player] - Temp admin",
		"!mod [player] - Make moderator",
		"!unmod [player] - Remove moderator",
		"!owner [player] - Make owner",
		"",
		"=== UTILITY ===",
		"!players - List players",
		"!admins - List admins",
		"!bans - List bans",
		"!muted - List muted",
		"!logs - Command logs",
		"!ping - Check ping",
		"!info - Server info",
		"!stats [player] - Player stats",
		"!warn [player] - Warn player",
		"!warnings - List warnings",
		"!clearwarnings [player] - Clear warns",
		"",
		"=== QUICK EXAMPLES ===",
		"Music: !music 142376088 (Megalovania)",
		"Music: !music 27697743 (Rickroll)",
		"Volume: !volume 5 (50% volume)",
		"Stop: !music stop or !stopmusic",
		"List: !musiclist (Show all music IDs)",
		"=== PERMANENT BANS (Official API) ===",
		"!pcban [id] [duration] [reason] - Permanent cross-game ban",
		"!pcunban [id] - Remove permanent ban",
		"",
}
	local helpText = "admin system - commands LIST\n\n" .. table.concat(categories, "\n")
	message("Command Help", helpText, {plr}, 30, "info")
end


commands["help"] = commands["cmds"]

commands["players"] = function(plr, args)
	local list = "Online Players ("..game.Players.NumPlayers.."):\n\n"
	for _, player in pairs(game.Players:GetPlayers()) do
		local status = ""
		if isOwner(player.Name) then
			status = " [Owner]"
		elseif isAdmin(player.Name) then
			status = " [Admin]"
		elseif isMod(player.Name) then
			status = " [Mod]"
		end
		list = list .. "â€¢ " .. player.Name .. status .. "\n"
	end
	message("Players Online", list, {plr})
end

commands["admins"] = function(plr, args)
	local list = "Administrators:\n\n"
	list = list .. "Owners:\n"..table.concat(owners, ", ").."\n\n"
	list = list .. "Admins:\n"..table.concat(admins, ", ").."\n\n"
	list = list .. "Temp Admins:\n"..table.concat(tempAdmins, ", ").."\n\n"
	list = list .. "Moderators:\n"..table.concat(mods, ", ")
	message("Admin List", list, {plr})
end

commands["bans"] = function(plr, args)
	if #bannedPlayers == 0 then
		message("Ban List", "No players are currently banned.", {plr})
	else
		local list = "Banned Players ("..#bannedPlayers.."):\n\n"
		for _, name in pairs(bannedPlayers) do
			list = list .. "â€¢ " .. name .. "\n"
		end
		message("Ban List", list, {plr})
	end
end

commands["muted"] = function(plr, args)
	if #mutedPlayers == 0 then
		message("Muted List", "No players are currently muted.", {plr})
	else
		local list = "Muted Players ("..#mutedPlayers.."):\n\n"
		for _, name in pairs(mutedPlayers) do
			list = list .. "â€¢ " .. name .. "\n"
		end
		message("Muted List", list, {plr})
	end
end

commands["logs"] = function(plr, args)
	if #commandLogs == 0 then
		message("Command Logs", "No commands have been logged yet.", {plr})
	else
		local logText = "Recent Commands:\n\n"
		local startIndex = math.max(1, #commandLogs - 9)
		for i = startIndex, #commandLogs do
			local log = commandLogs[i]
			logText = logText .. string.format("[%s]\n%s: !%s %s\n\n", 
				log.time, log.player, log.command, table.concat(log.args, " "))
		end
		message("Command Logs", logText, {plr}, 15)
	end
end

commands["ping"] = function(plr, args)
	local ping = math.floor(plr:GetNetworkPing() * 1000)
	local status = ping < 100 and "Excellent" or ping < 200 and "Good" or ping < 300 and "Fair" or "Poor"
	toast("Ping: "..ping.."ms ("..status..")", {plr}, 3, "info")
end

commands["info"] = function(plr, args)
	local info = "Server Information:\n\n"
	info = info .. "Game: "..game.Name.."\n"
	info = info .. "Place ID: "..game.PlaceId.."\n"
	info = info .. "Players: "..game.Players.NumPlayers.."/"..game.Players.MaxPlayers.."\n"
	info = info .. "Server Time: "..os.date("%H:%M:%S").."\n"
	info = info .. "Uptime: "..math.floor(tick()/60).." minutes\n"
	info = info .. "Gravity: "..workspace.Gravity.."\n"
	message("Server Info", info, {plr})
end

commands["credits"] = function(plr, args)
	local credits = "ADMIN SYSTEM V4\n\n"
	credits = credits .. "600+ Commands\n"
	credits = credits .. "Safe & Secure\n"
	credits = credits .. "Modern UI System\n"
	credits = credits .. "Rate Limited\n"
	credits = credits .. "Complete Logging\n"
	credits = credits .. "Player Management\n"
	credits = credits .. "Server Control\n\n"
	credits = credits .. "Created for Roblox 2008"
	message("Credits", credits, {plr})
end

commands["version"] = function(plr, args)
	toast("Admin System V4.0 - 600+ Commands", {plr}, 4, "success")
end

commands["stats"] = function(plr, args)
	local target = getPlayers(plr, args[1] or "me")[1]
	if target and target.Character then
		local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
		local stats = "Player Statistics:\n\n"
		stats = stats .. "Name: " .. target.Name .. "\n"
		stats = stats .. "User ID: " .. target.UserId .. "\n"
		stats = stats .. "Account Age: " .. target.AccountAge .. " days\n"
		if humanoid then
			stats = stats .. "Health: " .. math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth) .. "\n"
			stats = stats .. "Walk Speed: " .. humanoid.WalkSpeed .. "\n"
			stats = stats .. "Jump Power: " .. humanoid.JumpPower .. "\n"
		end
		message("Player Stats", stats, {plr})
	end
end

commands["serverinfo"] = function(plr, args)
	local info = "Detailed Server Info:\n\n"
	info = info .. "Place: " .. game.Name .. "\n"
	info = info .. "ID: " .. game.PlaceId .. "\n"
	info = info .. "Players: " .. game.Players.NumPlayers .. "/" .. game.Players.MaxPlayers .. "\n"
	info = info .. "Workspace Objects: " .. #workspace:GetChildren() .. "\n"
	info = info .. "Lighting Time: " .. game:GetService("Lighting").ClockTime .. "\n"
	info = info .. "Gravity: " .. workspace.Gravity .. "\n"
	message("Server Information", info, {plr})
end

commands["playerinfo"] = function(plr, args)
	local target = getPlayers(plr, args[1] or "me")[1]
	if target then
		local info = "Player Information:\n\n"
		info = info .. "Username: " .. target.Name .. "\n"
		info = info .. "Display Name: " .. target.DisplayName .. "\n"
		info = info .. "User ID: " .. target.UserId .. "\n"
		info = info .. "Account Age: " .. target.AccountAge .. " days\n"
		info = info .. "Membership: " .. tostring(target.MembershipType) .. "\n"
		info = info .. "Team: " .. (target.Team and target.Team.Name or "None") .. "\n"
		info = info .. "Admin Level: "

		if isOwner(target.Name) then
			info = info .. "Owner"
		elseif isAdmin(target.Name) then
			info = info .. "Admin"
		elseif isMod(target.Name) then
			info = info .. "Moderator"
		else
			info = info .. "Player"
		end

		message("Player Info", info, {plr})
	end
end

commands["weather"] = function(plr, args)
	local weatherTypes = {
		clear = {fogEnd = 100000, brightness = 1},
		rain = {fogEnd = 500, brightness = 0.7},
		storm = {fogEnd = 300, brightness = 0.5},
		snow = {fogEnd = 800, brightness = 0.9},
		fog = {fogEnd = 100, brightness = 0.8}
	}

	local weather = args[1] or "clear"
	if weatherTypes[weather] then
		local lighting = game:GetService("Lighting")
		lighting.FogEnd = weatherTypes[weather].fogEnd
		lighting.Brightness = weatherTypes[weather].brightness
		toast("Weather set to: " .. weather:upper(), {plr}, 3, "success")
	else
		toast("Available weather: clear, rain, storm, snow, fog", {plr}, 3, "error")
	end
end

commands["notify"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !notify [text]", {plr}, 3, "error")
		return 
	end

	local msgText = table.concat(args, " ")
	hint(msgText, game.Players:GetPlayers(), 5)
	toast("Notification sent to all players", {plr}, 3, "success")
end

commands["success"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !success [text]", {plr}, 3, "error")
		return 
	end

	local msgText = table.concat(args, " ")
	toast(msgText, game.Players:GetPlayers(), 4, "success")
	toast("Success message sent", {plr}, 3, "success")
end

commands["error"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !error [text]", {plr}, 3, "error")
		return 
	end

	local msgText = table.concat(args, " ")
	toast(msgText, game.Players:GetPlayers(), 4, "error")
	toast("Error message sent", {plr}, 3, "success")
end

commands["warning"] = function(plr, args)
	if #args < 1 then 
		toast("Usage: !warning [text]", {plr}, 3, "error")
		return 
	end

	local msgText = table.concat(args, " ")
	alert("Warning", msgText, game.Players:GetPlayers(), "warning")
	toast("Warning sent to all players", {plr}, 3, "success")
end

local function onPlayerChatted(plr)
	plr.Chatted:Connect(function(msg)

		if #msg > maxCommandLength then 
			toast("Message too long!", {plr}, 3, "error")
			return 
		end

		if not checkRateLimit(plr) then 
			toast("Rate limit exceeded. Please wait.", {plr}, 3, "error")
			return 
		end

		if isMuted(plr.Name) and msg:sub(1, #prefix) == prefix then
			toast("You are muted and cannot use commands.", {plr}, 3, "error")
			return
		end

		if msg:sub(1, #prefix) == prefix then
			local split = msg:sub(#prefix+1):split(" ")
			local cmd = split[1]:lower()
			table.remove(split, 1)

			if commands[cmd] then
				if isAdmin(plr.Name) or isOwner(plr.Name) then
					
					logCommand(plr, cmd, split)
					
					local success, err = pcall(function()
						commands[cmd](plr, split)
					end)
					if not success then
						toast("Command error: " .. tostring(err), {plr}, 4, "error")
						print("Command Error ("..plr.Name.."):", cmd, err)
					end
				else
					toast("Insufficient permissions.", {plr}, 3, "error")
				end
			else
				toast("Unknown command: " .. cmd, {plr}, 3, "warning")
			end
		end
	end)
end

local function setupPlayer(plr)
	if not plr then return end

	local function safeCall(fn, ...)
		if type(fn) == "function" then
			local success, result = pcall(fn, ...)
			if success then
				return result
			end
		end
		return nil
	end

	local banned = safeCall(isBanned, plr.Name)
	if banned then
		plr:Kick("You are banned from this server.")
		return
	end

	local groupAdmin = safeCall(isGroupAdmin, plr)
	local admin = safeCall(isAdmin, plr.Name)
	if groupAdmin and not admin then
		table.insert(admins, plr.Name)
		admin = true
	end

	if vipAdminBadgeId and vipAdminBadgeId > 0 then
		local success, hasBadge = pcall(function()
			return game:GetService("BadgeService"):UserHasBadge(plr.UserId, vipAdminBadgeId)
		end)
		if success and hasBadge then
			table.insert(tempAdmins, plr.Name)
			admin = true
		end
	end

	if admin then
		safeCall(toast, "Welcome back, "..plr.Name.."!\nType !cmds for commands", {plr}, 5, "success")
	end

	safeCall(onPlayerChatted, plr)
end

for _, plr in pairs(game.Players:GetPlayers()) do
	setupPlayer(plr)
end

game.Players.PlayerAdded:Connect(setupPlayer)

game.Players.PlayerRemoving:Connect(function(plr)
	rateLimit[plr.Name] = nil
	playerData[plr.Name] = nil
end)

print("Owner: " .. table.concat(owners, ", "))
print("Prefix: " .. prefix)

for _, plr in pairs(game.Players:GetPlayers()) do
	if plr and plr:FindFirstChild("PlayerGui") then
		createHintGui(plr.PlayerGui, "Admin System V4 loaded! Type !cmds for commands", 8)
	end
end

function countTable(t)
	local count = 0
	for _ in pairs(t) do
		count = count + 1
	end
	return count
end

print("loaded: " .. countTable(commands))
toast("loaded with "..countTable(commands).." commands", game.Players:GetPlayers(), 5, "success")
